// ================== é…ç½®éƒ¨åˆ† ==================
const NOTION_TOKEN = 'ntn_b32235170706VL1CKuyYng7TG47wZPdkMHtfbEn3IBgegv';
const DATABASE_ID = '1a10c022f78e80cd9019d7c146ddf306';
const TG_TOKEN = '8029665644:AAEwB9oi-NCAObluhEdXSJP1ToptV50_r_k';
const VERSION = '5.0';

// è…¾è®¯äº‘ COS é…ç½®ï¼ˆè¯·æ›¿æ¢ä¸ºä½ çš„ä¿¡æ¯ï¼‰
const COS_BUCKET_NAME = 'png-1253420449';
const COS_REGION = 'ap-chongqing';
// è…¾è®¯äº‘ COS é…ç½®ï¼ˆè¯·æ›¿æ¢ä¸ºä½ çš„ä¿¡æ¯ï¼‰
const COS_SECRET_ID = 'xxx';
// è…¾è®¯äº‘ COS é…ç½®ï¼ˆè¯·æ›¿æ¢ä¸ºä½ çš„ä¿¡æ¯ï¼‰
const COS_SECRET_KEY = 'xxx';
const COS_DOMAIN = 'https://png-1253420449.cos.ap-chongqing.myqcloud.com';

// ================== å·¥å…·å‡½æ•° ==================
// ç”¨äºè½¬ä¹‰ Markdown å­—ç¬¦
function escapeMD(text) {
  return text.replace(/[_*[\]()~`>#+=|{}.!-]/g, '\\$&');
}

// è‡ªåŠ¨ç”Ÿæˆæ ‡ç­¾ï¼ˆåŒ…æ‹¬è‡ªå®šä¹‰å’Œè‡ªåŠ¨åŒ¹é…æ ‡ç­¾ï¼‰
function generateTags(content) {
  const customTags = [...new Set(content.match(/#(\p{L}+)/gu) || [])].map(t => t.slice(1));
  const AUTO_TAGS = {
    'å·¥ä½œ': ['ä¼šè®®', 'é¡¹ç›®', 'æ±‡æŠ¥', 'å®¢æˆ·'],
    'å­¦ä¹ ': ['ç¬”è®°', 'è¯¾ç¨‹', 'è®ºæ–‡', 'é˜…è¯»'],
    'ç”Ÿæ´»': ['è´­ç‰©', 'é£Ÿè°±', 'å¥åº·', 'æ—…è¡Œ']
  };
  const autoTags = Object.entries(AUTO_TAGS)
    .filter(([_, keywords]) => keywords.some(kw => content.includes(kw)))
    .map(([tag]) => tag);
  return [...new Set([...customTags, ...autoTags])];
}

// ================== Notion äº¤äº’ ==================
function getNotionHeaders() {
  return {
    'Authorization': `Bearer ${NOTION_TOKEN}`,
    'Content-Type': 'application/json',
    'Notion-Version': '2022-06-28'
  };
}

async function saveToNotion({ title, content, tags, children, userId }) {
  const body = {
    parent: { database_id: DATABASE_ID },
    icon: { type: 'emoji', emoji: 'ğŸ“˜' },
    properties: {
      'æ ‡é¢˜': { title: [{ text: { content: title.substring(0, 200) } }] },
      'å†…å®¹': { rich_text: [{ text: { content: content.substring(0, 2000) } }] },
      'æ ‡ç­¾': { multi_select: tags.slice(0, 5).map(tag => ({ name: tag })) },
      'æ—¥æœŸ': { date: { start: new Date().toISOString() } },
      'ç”¨æˆ·ID': { rich_text: [{ text: { content: userId.toString() } }] }
    },
    children: [
      ...(children || []),
      {
        object: 'block',
        type: 'paragraph',
        paragraph: { rich_text: [{ text: { content: content + '\n\n' } }] }
      }
    ]
  };

  const response = await fetch('https://api.notion.com/v1/pages', {
    method: 'POST',
    headers: getNotionHeaders(),
    body: JSON.stringify(body)
  });

  if (!response.ok) {
    const error = await response.json();
    throw new Error(`Notion APIé”™è¯¯: ${error.message}`);
  }
  return await response.json();
}

// ================== è…¾è®¯äº‘ COS ç­¾ååŠä¸Šä¼  ==================
async function getAuthorization({ SecretId, SecretKey, Method, Key, Bucket, Region }) {
  const now = Math.floor(Date.now() / 1000);
  const exp = now + 3600; // æœ‰æ•ˆæœŸ1å°æ—¶
  const signTime = `${now};${exp}`;
  const keyTime = signTime;
  const signKey = await hmacSha1(SecretKey, keyTime);
  const httpString = `${Method.toLowerCase()}\n/${Key}\n\n\n`;
  const stringToSign = `sha1\n${signTime}\n${await sha1(httpString)}\n`;
  const signature = await hmacSha1(signKey, stringToSign);
  return `q-sign-algorithm=sha1&q-ak=${SecretId}&q-sign-time=${signTime}&q-key-time=${keyTime}&q-header-list=&q-url-param-list=&q-signature=${signature}`;
}

async function hmacSha1(key, msg) {
  const cryptoKey = await crypto.subtle.importKey(
    'raw',
    new TextEncoder().encode(key),
    { name: 'HMAC', hash: 'SHA-1' },
    false,
    ['sign']
  );
  const signature = await crypto.subtle.sign(
    'HMAC',
    cryptoKey,
    new TextEncoder().encode(msg)
  );
  return Array.from(new Uint8Array(signature))
    .map(b => b.toString(16).padStart(2, '0'))
    .join('');
}

async function sha1(msg) {
  const msgBuffer = new TextEncoder().encode(msg);
  const hashBuffer = await crypto.subtle.digest('SHA-1', msgBuffer);
  return Array.from(new Uint8Array(hashBuffer))
    .map(b => b.toString(16).padStart(2, '0'))
    .join('');
}

// ä¸Šä¼ æ–‡ä»¶åˆ° COSï¼Œå¹¶è¿”å›æ–‡ä»¶çš„å¤–é“¾ URL
async function uploadToCos(fileUrl, contentType) {
  // ä¸‹è½½æ–‡ä»¶æ•°æ®
  const response = await fetch(fileUrl);
  const fileBuffer = await response.arrayBuffer();
  const timestamp = Date.now();
  // æ ¹æ® contentType å†³å®šæ–‡ä»¶æ‰©å±•å
  const ext = contentType === 'image/jpeg' ? 'jpg' : (contentType === 'video/mp4' ? 'mp4' : 'dat');
  const fileName = `telegram-file-${timestamp}.${ext}`;
  const authorization = await getAuthorization({
    SecretId: COS_SECRET_ID,
    SecretKey: COS_SECRET_KEY,
    Method: 'PUT',
    Key: fileName,
    Bucket: COS_BUCKET_NAME,
    Region: COS_REGION,
  });
  const cosUrl = `${COS_DOMAIN}/${fileName}`;
  const cosUploadUrl = `https://${COS_BUCKET_NAME}.cos.${COS_REGION}.myqcloud.com/${fileName}`;
  
  const uploadResp = await fetch(cosUploadUrl, {
    method: 'PUT',
    headers: {
      'Authorization': authorization,
      'Content-Type': contentType,
    },
    body: fileBuffer,
  });
  
  if (!uploadResp.ok) {
    throw new Error(`COS ä¸Šä¼ å¤±è´¥ï¼ŒçŠ¶æ€ç ï¼š${uploadResp.status}`);
  }
  
  return cosUrl;
}

// ================== Telegram äº¤äº’ ==================
async function sendMessage(chatId, text, replyTo = null, markdown = true) {
  try {
    const response = await fetch(`https://api.telegram.org/bot${TG_TOKEN}/sendMessage`, {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify({
        chat_id: chatId,
        text: markdown ? text : escapeMD(text),
        reply_to_message_id: replyTo,
        parse_mode: markdown ? 'MarkdownV2' : undefined,
        disable_web_page_preview: true
      })
    });
    const responseData = await response.json();
    console.log(`sendMessage response: ${JSON.stringify(responseData)}`);
  } catch (error) {
    console.error('å‘é€æ¶ˆæ¯å¤±è´¥:', error);
  }
}

// ================== æ–‡ä»¶ URL è·å– ==================
async function getTelegramFileUrl(fileId) {
  const res = await fetch(`https://api.telegram.org/bot${TG_TOKEN}/getFile?file_id=${fileId}`);
  const data = await res.json();
  if (!data.ok) throw new Error('è·å–æ–‡ä»¶ä¿¡æ¯å¤±è´¥');
  return `https://api.telegram.org/file/bot${TG_TOKEN}/${data.result.file_path}`;
}

// ================== æ–‡ä»¶å›¾æ ‡ï¼ˆæ ¹æ®æ–‡ä»¶ç±»å‹ï¼‰ ==================
function getIcon(type) {
  const fileIcons = {
    pdf: 'ğŸ“„',
    ppt: 'ğŸ“Š',
    pptx: 'ğŸ“Š',
    doc: 'ğŸ“‘',
    docx: 'ğŸ“‘',
    xls: 'ğŸ“ˆ',
    xlsx: 'ğŸ“ˆ',
    zip: 'ğŸ“¦',
    rar: 'ğŸ“¦',
    md: 'ğŸ“',
    default: 'ğŸ“'
  };
  return fileIcons[type] || fileIcons.default;
}

// ================== Notion æœç´¢ã€ç»Ÿè®¡ç­‰åŠŸèƒ½ï¼ˆå¯é€‰ï¼‰ ==================
// æ­¤å¤„çœç•¥ç»Ÿè®¡åŠæœç´¢åŠŸèƒ½ä»£ç ï¼Œä½ å¯ä»¥æ ¹æ®éœ€è¦æ·»åŠ 

// ================== æ¶ˆæ¯å¤„ç† ==================
async function processMessage(message) {
  if (!message.text && !message.caption && !message.photo && !message.video && !message.document) {
    console.log('å¿½ç•¥æ— æ•ˆæ¶ˆæ¯ç±»å‹');
    return;
  }

  try {
    // å¦‚æœæ¶ˆæ¯ä¸ºå‘½ä»¤æ–‡æœ¬
    if (message.text && message.text.startsWith('/')) {
      await handleCommand(message);
      return;
    }

    // å¤„ç†æ–‡ä»¶ã€å›¾ç‰‡ã€è§†é¢‘æ¶ˆæ¯
    if (message.document || message.photo || message.video) {
      let fileUrl, blockType, fileName, contentType;
      const fileInfo = message.document || (message.photo && message.photo[message.photo.length - 1]) || message.video;
      if (message.document) {
        fileUrl = await getTelegramFileUrl(fileInfo.file_id);
        blockType = 'file';
        fileName = escapeMD(fileInfo.file_name || 'æ–‡ä»¶');
        contentType = 'application/octet-stream';
      } else if (message.photo) {
        fileUrl = await getTelegramFileUrl(fileInfo.file_id);
        blockType = 'image';
        fileName = 'å›¾ç‰‡';
        contentType = 'image/jpeg';
      } else if (message.video) {
        fileUrl = await getTelegramFileUrl(fileInfo.file_id);
        blockType = 'video';
        fileName = 'è§†é¢‘';
        contentType = 'video/mp4';
      }

      // ä¸‹è½½æ–‡ä»¶å¹¶ä¸Šä¼ åˆ° COS
      const cosFileUrl = await uploadToCos(fileUrl, contentType);
      // å¤„ç†æ–‡å­—è¯´æ˜
      const caption = message.caption || '';
      const cleanContent = caption.replace(/#\p{L}+/gu, '').trim();
      const tags = generateTags(caption);

      // å°†æ–‡ä»¶é“¾æ¥ä½œä¸ºå­å—æ·»åŠ åˆ° Notion é¡µé¢ä¸­
      const childrenBlock = {
        object: 'block',
        type: blockType === 'file' ? 'file' : blockType,
        [blockType]: blockType === 'file'
          ? { external: { url: cosFileUrl }, caption: [{ text: { content: fileName } }] }
          : { external: { url: cosFileUrl } }
      };

      await saveToNotion({
        title: `${getIcon(blockType)} ${message.from.first_name}çš„${fileName}`,
        content: cleanContent || 'æ— æ–‡å­—è¯´æ˜',
        tags: tags,
        userId: message.from.id,
        children: [childrenBlock]
      });

      await sendMessage(
        message.chat.id,
        `âœ… ${fileName} å·²æˆåŠŸä¿å­˜åˆ° Notion\nCOS é“¾æ¥: ${cosFileUrl}${tags.length ? '\næ ‡ç­¾ï¼š' + tags.join(' ') : ''}`,
        message.message_id,
        false
      );
      return;
    }

    // å¤„ç†çº¯æ–‡æœ¬æ¶ˆæ¯
    if (message.text) {
      const content = message.text;
      const tags = generateTags(content);
      await saveToNotion({
        title: `ğŸ“ ${message.from.first_name}çš„ç¬”è®°`,
        content: content.replace(/#\p{L}+/gu, '').trim(),
        tags: tags,
        userId: message.from.id
      });
      await sendMessage(
        message.chat.id,
        `âœ… æ–‡æœ¬å·²ä¿å­˜${tags.length ? '\næ ‡ç­¾ï¼š' + tags.join(' ') : ''}`,
        message.message_id
      );
      return;
    }
  } catch (error) {
    console.error('å¤„ç†æ¶ˆæ¯å¤±è´¥:', error);
    await sendMessage(
      message.chat.id,
      `âŒ ä¿å­˜å¤±è´¥ï¼š${error.message}`,
      message.message_id,
      false
    );
  }
}

// ================== å‘½ä»¤å¤„ç†å™¨ ==================
async function handleCommand(message) {
  const [command, ...args] = message.text.split(' ');
  const query = args.join(' ');
  try {
    switch (command.toLowerCase()) {
      case '/start':
        await sendMessage(
          message.chat.id,
          `ğŸ“š æ™ºèƒ½çŸ¥è¯†åº“åŠ©æ‰‹\næ¬¢è¿ä½¿ç”¨ï¼ç‰ˆæœ¬ï¼š${VERSION}\nç›´æ¥å‘é€å†…å®¹å³å¯ä¿å­˜ï¼Œæ”¯æŒå›¾ç‰‡/æ–‡ä»¶/è§†é¢‘`,
          message.message_id
        );
        break;
      case '/help':
        await sendMessage(
          message.chat.id,
          `å¸®åŠ©ä¸­å¿ƒ\n
/start - å¼€å§‹ä½¿ç”¨
/help - å¸®åŠ©ä¿¡æ¯
/search - æœç´¢ï¼ˆå¯é€‰ï¼‰
/status - è´¦æˆ·çŠ¶æ€`,
          message.message_id
        );
        break;
      default:
        await sendMessage(
          message.chat.id,
          'âŒ æœªçŸ¥å‘½ä»¤ï¼Œå¯ç”¨å‘½ä»¤ï¼š\n/start\n/help',
          message.message_id,
          false
        );
    }
  } catch (error) {
    console.error('å‘½ä»¤å¤„ç†é”™è¯¯:', error);
    await sendMessage(
      message.chat.id,
      `âŒ æ“ä½œå¤±è´¥ï¼š${escapeMD(error.message)}`,
      message.message_id,
      false
    );
  }
}

// ================== Worker å…¥å£ ==================
async function handleRequest(request) {
  try {
    const url = new URL(request.url);
    // Telegram Webhook ä½¿ç”¨ POST è¯·æ±‚ï¼Œè·¯å¾„è®¾ç½®ä¸º /<TG_TOKEN>
    if (request.method === 'POST' && url.pathname === `/${TG_TOKEN}`) {
      const update = await request.json();
      if (update.message) {
        await processMessage(update.message);
      }
      return new Response('OK');
    }
    return new Response('Not Found', { status: 404 });
  } catch (error) {
    console.error('å…¨å±€é”™è¯¯:', error);
    return new Response(error.stack, { status: 500 });
  }
}

addEventListener('fetch', event => {
  event.respondWith(handleRequest(event.request));
});
